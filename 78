import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders } from '../_shared/cors.ts';

// Define the types directly within the function for clarity and portability.
interface Tutor {
  id: string;
  name: string;
  video_url: string;
  created_at: string;
}

interface Batch {
  name: string;
}

interface RecurringClass {
  id: string;
  batch_id: string;
  created_at: string;
  day_of_week: number;
  end_time: string;
  start_time: string;
  thumbnail_url: string | null;
  title: string;
  tutor_id: string;
  tutors: Tutor;
  batches: Batch | null;
}

interface AppClassSession {
  id: string;
  recurring_class_id: string;
  title: string;
  batch: string;
  batchId: string;
  startTime: string; // ISO String
  endTime: string; // ISO String
  thumbnailUrl: string;
  tutor: Tutor;
}

// This logic is moved to the server-side function
const generateSessionsFromRecurring = (recurringClasses: RecurringClass[]): AppClassSession[] => {
  const now = new Date();
  const materializedSessions: AppClassSession[] = [];

  recurringClasses.forEach(rc => {
    for (let i = -7; i <= 14; i++) {
      const dateToCheck = new Date();
      dateToCheck.setDate(now.getDate() + i);
      
      if (dateToCheck.getDay() === rc.day_of_week) {
        const [startHour, startMinute] = rc.start_time.split(':').map(Number);
        const [endHour, endMinute] = rc.end_time.split(':').map(Number);

        const startTime = new Date(dateToCheck);
        startTime.setHours(startHour, startMinute, 0, 0);

        const endTime = new Date(dateToCheck);
        endTime.setHours(endHour, endMinute, 0, 0);

        materializedSessions.push({
          id: `${rc.id}-${startTime.toISOString().split('T')[0]}`,
          recurring_class_id: rc.id,
          title: rc.title,
          batch: rc.batches?.name || 'Unknown Batch',
          batchId: rc.batch_id,
          startTime: startTime.toISOString(),
          endTime: endTime.toISOString(),
          thumbnailUrl: rc.thumbnail_url || 'https://img-wrapper.vercel.app/image?url=https://placehold.co/400x225/1C1C22/E0E0E6?text=No+Image',
          tutor: rc.tutors,
        });
      }
    }
  });

  return materializedSessions;
};


Deno.serve(async (req) => {
  // This is needed to handle CORS preflight requests.
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      { global: { headers: { Authorization: req.headers.get('Authorization')! } } }
    );

    const url = new URL(req.url);
    const status = url.searchParams.get('status') as 'live' | 'upcoming' | 'completed' | null;

    if (!status) {
      return new Response(JSON.stringify({ error: 'Missing "status" query parameter. Use "live", "upcoming", or "completed".' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      });
    }

    const { data, error } = await supabaseClient
      .from('recurring_classes')
      .select(`
          *,
          batches ( name ),
          tutors ( * )
      `);

    if (error) throw error;

    const allPossibleSessions = generateSessionsFromRecurring(data as RecurringClass[]);
    const now = new Date();

    const filteredSessions = allPossibleSessions.filter(session => {
        const startTime = new Date(session.startTime);
        const endTime = new Date(session.endTime);
        const isToday = startTime.toDateString() === now.toDateString();

        if (status === 'live') {
            return startTime <= now && endTime > now;
        }
        if (status === 'upcoming') {
            return startTime > now && isToday;
        }
        if (status === 'completed') {
            return endTime <= now && isToday;
        }
        return false;
    });

    filteredSessions.sort((a, b) => {
        const startTimeA = new Date(a.startTime).getTime();
        const startTimeB = new Date(b.startTime).getTime();
        if (status === 'completed') {
            return startTimeB - startTimeA;
        }
        return startTimeA - startTimeB;
    });

    return new Response(JSON.stringify(filteredSessions), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (err) {
    return new Response(String(err?.message ?? err), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    });
  }
});
