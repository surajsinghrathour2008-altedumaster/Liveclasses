import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import toast from 'react-hot-toast';
import { AppClassSession, RecurringClass } from '@/types';
import { getTodaysRecurringClasses } from '@/services/api';
import ClassNotificationToast from '@/components/ClassNotificationToast';

const ClassNotificationContext = createContext<undefined>(undefined);

const NOTIFICATION_INTERVAL = 30000; // Check every 30 seconds

const NOTIFICATION_THRESHOLDS = [
    { minutes: 60, id: '60m_before', message: (title: string) => `"${title}" is starting in 1 hour!` },
    { minutes: 10, id: '10m_before', message: (title: string) => `"${title}" is starting in 10 minutes!` },
    { minutes: 0, id: '0m_start', message: (title: string) => `"${title}" is starting now!` },
    { minutes: -10, id: '10m_after', message: (title: string) => `"${title}" started 10 minutes ago. Join now!` },
];

const generateTodaysSessions = (recurringClasses: (RecurringClass & { batches: { name: string } | null })[]): AppClassSession[] => {
    const now = new Date();
    const todaySessions: AppClassSession[] = [];

    recurringClasses.forEach(rc => {
        const [startHour, startMinute] = rc.start_time.split(':').map(Number);
        const [endHour, endMinute] = rc.end_time.split(':').map(Number);

        const startTime = new Date();
        startTime.setHours(startHour, startMinute, 0, 0);

        const endTime = new Date();
        endTime.setHours(endHour, endMinute, 0, 0);

        if (endTime > now) {
            todaySessions.push({
                id: `${rc.id}-${startTime.toISOString().split('T')[0]}`,
                recurring_class_id: rc.id,
                title: rc.title,
                batch: rc.batches?.name || 'Unknown Batch',
                batchId: rc.batch_id,
                startTime,
                endTime,
                thumbnailUrl: rc.thumbnail_url || 'https://img-wrapper.vercel.app/image?url=https://img-wrapper.vercel.app/image?url=https://placehold.co/400x225/1C1C22/E0E0E6?text=No+Image',
                tutor: rc.tutors,
            });
        }
    });
    return todaySessions;
};

export const ClassNotificationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [todaysSessions, setTodaysSessions] = useState<AppClassSession[]>([]);
    const [sentNotifications, setSentNotifications] = useState<Record<string, string[]>>({});
    const [lastCheckTime, setLastCheckTime] = useState(new Date().getTime());
    const [currentDate, setCurrentDate] = useState(new Date().toDateString());

    // Fetch classes whenever the date changes
    useEffect(() => {
        getTodaysRecurringClasses()
            .then(recurring => {
                const sessions = generateTodaysSessions(recurring);
                setTodaysSessions(sessions);
                // Reset sent notifications for the new day
                setSentNotifications({});
            })
            .catch(err => console.error("Failed to fetch today's classes for notifications:", err));
    }, [currentDate]);

    // Run the notification checker on an interval
    useEffect(() => {
        const intervalId = setInterval(() => {
            const now = new Date();
            const nowTime = now.getTime();
            
            // Check if the day has changed
            if (now.toDateString() !== currentDate) {
                setCurrentDate(now.toDateString());
                // The useEffect above will handle refetching and resetting state
                return;
            }

            todaysSessions.forEach(session => {
                const startTime = session.startTime.getTime();

                NOTIFICATION_THRESHOLDS.forEach(threshold => {
                    const notificationTime = startTime - (threshold.minutes * 60 * 1000);
                    const hasBeenSent = sentNotifications[session.id]?.includes(threshold.id);

                    if (!hasBeenSent && notificationTime > lastCheckTime && notificationTime <= nowTime) {
                        toast.custom(
                            (t) => <ClassNotificationToast t={t} session={session} message={threshold.message(session.title)} />,
                            { duration: 15000, position: 'top-right' }
                        );

                        setSentNotifications(prev => ({
                            ...prev,
                            [session.id]: [...(prev[session.id] || []), threshold.id]
                        }));
                    }
                });
            });

            setLastCheckTime(nowTime);

        }, NOTIFICATION_INTERVAL);

        return () => clearInterval(intervalId);
    }, [todaysSessions, sentNotifications, lastCheckTime, currentDate]);

    return (
        <ClassNotificationContext.Provider value={undefined}>
            {children}
        </ClassNotificationContext.Provider>
    );
};

export const useClassNotifications = () => {
    const context = useContext(ClassNotificationContext);
    if (context === undefined) {
        throw new Error('useClassNotifications must be used within a ClassNotificationProvider');
    }
    return context;
};
