import { createClient } from '@supabase/supabase-js';
import type { Handler, HandlerEvent } from "@netlify/functions";

// Type definitions for clarity
interface Tutor {
  id: string;
  name: string;
  video_url: string;
  created_at: string;
}

interface Batch {
  name: string;
}

interface RecurringClass {
  id: string;
  batch_id: string;
  created_at: string;
  day_of_week: number;
  end_time: string;
  start_time: string;
  thumbnail_url: string | null;
  title: string;
  tutor_id: string;
  tutors: Tutor;
  batches: Batch | null;
}

interface AppClassSession {
  id: string;
  recurring_class_id: string;
  title: string;
  batch: string;
  batchId: string;
  startTime: string; // ISO String
  endTime: string; // ISO String
  thumbnailUrl: string;
  tutor: Tutor;
}

const generateSessionsFromRecurring = (recurringClasses: RecurringClass[]): AppClassSession[] => {
  const now = new Date();
  const materializedSessions: AppClassSession[] = [];

  recurringClasses.forEach(rc => {
    // Ensure tutor data is valid before processing
    if (!rc.tutors || typeof rc.tutors !== 'object') return;
      
    // Check for sessions in a window around today to catch all relevant instances
    for (let i = -7; i <= 14; i++) {
      const dateToCheck = new Date();
      dateToCheck.setDate(now.getDate() + i);
      
      if (dateToCheck.getDay() === rc.day_of_week) {
        const [startHour, startMinute] = rc.start_time.split(':').map(Number);
        const [endHour, endMinute] = rc.end_time.split(':').map(Number);

        const startTime = new Date(dateToCheck);
        startTime.setHours(startHour, startMinute, 0, 0);

        const endTime = new Date(dateToCheck);
        endTime.setHours(endHour, endMinute, 0, 0);

        materializedSessions.push({
          id: `${rc.id}-${startTime.toISOString().split('T')[0]}`,
          recurring_class_id: rc.id,
          title: rc.title,
          batch: rc.batches?.name || 'Unknown Batch',
          batchId: rc.batch_id,
          startTime: startTime.toISOString(),
          endTime: endTime.toISOString(),
          thumbnailUrl: rc.thumbnail_url || 'https://img-wrapper.vercel.app/image?url=https://img-wrapper.vercel.app/image?url=https://img-wrapper.vercel.app/image?url=https://placehold.co/400x225/1C1C22/E0E0E6?text=No+Image',
          tutor: rc.tutors,
        });
      }
    }
  });
  return materializedSessions;
};

const handler: Handler = async (event: HandlerEvent) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
  };

  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 200, headers: corsHeaders };
  }

  try {
    // Use standard, non-prefixed environment variables for the server-side function
    const supabaseUrl = process.env.SUPABASE_URL;
    const supabaseAnonKey = process.env.SUPABASE_ANON_KEY;

    if (!supabaseUrl || !supabaseAnonKey) {
      throw new Error("Supabase URL and Anon Key are not configured in the server environment.");
    }

    const supabaseClient = createClient(supabaseUrl, supabaseAnonKey);

    const status = event.queryStringParameters?.status as 'live' | 'upcoming' | 'completed' | null;

    if (!status) {
      return {
        statusCode: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Missing "status" query parameter. Use "live", "upcoming", or "completed".' }),
      };
    }

    const { data, error } = await supabaseClient
      .from('recurring_classes')
      .select(`*, batches ( name ), tutors ( * )`);

    if (error) throw error;

    const allPossibleSessions = generateSessionsFromRecurring(data as any[]);
    const now = new Date();

    const filteredSessions = allPossibleSessions.filter(session => {
        const startTime = new Date(session.startTime);
        const endTime = new Date(session.endTime);
        const isToday = startTime.toDateString() === now.toDateString();

        if (status === 'live') return startTime <= now && endTime > now;
        if (status === 'upcoming') return startTime > now && isToday;
        if (status === 'completed') return endTime <= now && isToday;
        return false;
    });

    filteredSessions.sort((a, b) => {
        const startTimeA = new Date(a.startTime).getTime();
        const startTimeB = new Date(b.startTime).getTime();
        return status === 'completed' ? startTimeB - startTimeA : startTimeA - startTimeB;
    });

    return {
      statusCode: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      body: JSON.stringify(filteredSessions),
    };
  } catch (err: any) {
    return {
      statusCode: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      body: JSON.stringify({ error: err.message || 'An unknown error occurred.' }),
    };
  }
};

export { handler };
